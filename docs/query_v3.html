<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Bitquery · bitdb</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&gt; Bitquery: An Instant Open API for Bitcoin Applications"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Bitquery · bitdb"/><meta property="og:type" content="website"/><meta property="og:url" content="https://docs.bitdb.network/index.html"/><meta property="og:description" content="&gt; Bitquery: An Instant Open API for Bitcoin Applications"/><meta property="og:image" content="https://docs.bitdb.network/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://docs.bitdb.network/img/docusaurus.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">bitdb</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="https://github.com/21centurymotorcompany/bitd" target="_self">GitHub</a></li><li class=""><a href="https://twitter.com/_unwriter" target="_self">Twitter</a></li><li class=""><a href="https://t.me/joinchat/HH1DDQ8pZlSlsdNcKgIcxw" target="_self">Chat</a></li><li class=""><a href="https://bitdb.network/v2/explorer" target="_self">Explorer</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docMainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Bitquery</h1></header><article><div><span><blockquote>
<p>Bitquery: An Instant Open API for Bitcoin Applications</p>
</blockquote>
<blockquote>
<p>Bitquery is a self-contained, portable, and programmable query language for Bitcoin.</p>
</blockquote>
<p>BitDB is an autonomous database that indexes Bitcoin in the most query-able manner possible.</p>
<p>Once indexed, you are free to query the database in whichever manner you want, but it is beneficial to have an open, portable, and standardized language to query BitDB. In fact, it's a critical factor in building an interoperable and  decentralized BitDB Network ecosystem.</p>
<ul>
<li>BitDB internally uses <strong>MongoDB</strong> to index the transactions in a structured manner. This means you can query it just like any regular MongoDB collection.</li>
<li>BitDB supports most MongoDB methods such as <strong>find, aggregate, sort, limit, skip, project,</strong> etc.</li>
<li>To query the database, you simply make a request to BitDB with a <strong>JSON-based query language</strong> that looks like this:</li>
</ul>
<p><img src="/docs/assets/ql3.png" alt="ql"></p>
<p>On top of MongoDB's native query language, Bitquery adds an additional layer to create a query language that's:</p>
<ul>
<li><strong>Programmable:</strong> A Turing complete data processing language for filtering/manipulating the db response before sending back to the client.</li>
<li><strong>Self-contained:</strong> The query completely stands on its own without the need to depend on a 3rd party system or schema. Can describe every step of the query lifecycle, including encoding, query, and post-processing logic.</li>
<li><strong>Portable:</strong> All of this expressed in JSON, the most ubiquitous portable data format in existence today. You don't need to write a separate program to process the response because that logic is embedded in the portable query itself.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="1-bitdb-document-format"></a><a href="#1-bitdb-document-format" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. BitDB Document Format</h2>
<p>Before looking at the query language, first make sure you understand how a bitcoin transaction is decoded and transformed and stored into a query-optimized format in BitDB.</p>
<p>You can learn about BitDB document format in the Indexer section: <a href="indexer">Learn Indexer</a></p>
<h2><a class="anchor" aria-hidden="true" id="2-bitquery-bitdb-query-language"></a><a href="#2-bitquery-bitdb-query-language" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. Bitquery: BitDB Query Language</h2>
<p>A BitDB query is a self-contained declarative JSON query object built on top of MongoDB query language. Every query consists of 3 top level attributes:</p>
<ol>
<li><strong>v:</strong> is for &quot;version&quot;. This documentation is based on v: 3 so always use v: 3 (v:1 and 2 will be deprecated)</li>
<li><strong>q:</strong> is for &quot;query&quot;.
<ul>
<li><strong>find:</strong> MongoDB query filter object. <a href="https://docs.mongodb.com/manual/reference/method/db.collection.find/">Learn more about MongoDB find command</a></li>
<li><strong>aggregate:</strong> MongoDB aggregationg pipeline stages array. <a href="https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/#db.collection.aggregate">Learn more about Mongodb aggregate stages</a></li>
<li><strong>project:</strong> MongoDB project operator for selectively returning attributes. <a href="https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/">Learn more about Mongodb projection</a></li>
<li><strong>sort:</strong> MongoDB sort operator. <a href="https://docs.mongodb.com/manual/reference/method/cursor.sort/">Learn more about Mongodb sort operator</a></li>
<li><strong>limit:</strong> MongoDB limit operator. Limit the number of results to return. <a href="https://docs.mongodb.com/manual/reference/method/cursor.limit/">Leanr more about MongoDB limit operator</a></li>
<li><strong>skip:</strong> MongoDB skip operator. Combining the &quot;limit&quot; and &quot;skip&quot; you can implement pagination. <a href="https://docs.mongodb.com/manual/reference/method/cursor.skip/">Learn more about MongoDB skip operator</a></li>
<li><strong>db:</strong> The name of the database type  The default is [&quot;c&quot;, &quot;u&quot;] (each representing &quot;confirmed&quot; and &quot;unconfirmed&quot; respectively), but you can explicitly query against only one of them, using [&quot;c&quot;], or [&quot;u&quot;]</li>
</ul></li>
<li><strong>r:</strong> is for &quot;response&quot;. This is the response processor.
<ul>
<li><strong>f:</strong> is for &quot;function&quot;. It's a single-line program for processing the DB response before sending back to the client. The supported language is <a href="https://stedolan.github.io/jq">jq</a>, <strong>a Turing complete, stack based JSON processing language.</strong></li>
</ul></li>
</ol>
<p>In the sections below, we will go through 3 important components of Bitquery:</p>
<ol>
<li><strong>Encoding:</strong> Abstract out all the messy encoding related challenges</li>
<li><strong>Query:</strong> MongoDB based query language</li>
<li><strong>Processing:</strong> Programmable response processing</li>
</ol>
<hr>
<h3><a class="anchor" aria-hidden="true" id="a-encoding"></a><a href="#a-encoding" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A. Encoding</h3>
<p>It is impossible to know the original encoding scheme of any random piece of bitcoin script push data. This is why we need to specify additional encoding information when querying BitDB.</p>
<h4><a class="anchor" aria-hidden="true" id="i-quickstart"></a><a href="#i-quickstart" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>i. Quickstart</h4>
<p>Just for getting started, you can skip the next section (&quot;Under the Hood&quot;) and just understand the following attributes:</p>
<ul>
<li>b0, b1, b2, b3, b4, ... : base64 encoded version of the script push data</li>
<li>h0, h1, h2, h3, h4, ... : hex encoded version of the script push data</li>
<li>s0, s1, s2, s3, s4, ... : UTF8 encoded version of the script push data</li>
</ul>
<p>Then check out the <a href="/docs/quickstart_v3">quickstart</a> to see some examples.</p>
<p>If you want to learn more about how these work behind the scenes, read on.</p>
<h4><a class="anchor" aria-hidden="true" id="ii-under-the-hood"></a><a href="#ii-under-the-hood" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ii. Under the Hood</h4>
<p>Because BitDB stores everything as base64 (b-attributes) and UTF8 (s-attributes) encoding, if we want to query with a hex encoded value, we need to manually specify that it's hex-encoded, so bitquery knows to transform it to base64 before making the query.</p>
<p>We could use a designated object for describing the encoding scheme of each push data but this results in a verbose query. There must be a simpler way of doing this.</p>
<p>In version 3, BitDB introduces a new concept called <strong>&quot;virtual attribute&quot;</strong> to make the query much more flexible, extensible, AND simpler. Here's how it works:</p>
<p><strong>Step 1. A client makes a query:</strong> Here's an example v3 query. Notice the <code>out.h1</code>. This is the virtual attribute in question. It's used for expressing <strong>hex encoded</strong> values:</p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: {
      <span class="hljs-attr">"out.h1"</span>: <span class="hljs-string">"6d02"</span>
    }
  }
}
</code></pre>
<p><strong>Step 2. Bitquery encodes the virtual attribute into base64:</strong> Bitquery then replaces the hex key/value (<code>&quot;out.h1&quot;: &quot;6d02&quot;</code>)into base64 counterpart (<code>&quot;out.b1&quot;: &quot;bQI=&quot;</code>). Above query is transformed at query time into:</p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: {
      <span class="hljs-attr">"out.b1"</span>: <span class="hljs-string">"bQI="</span>
    }
  }
}
</code></pre>
<p><strong>Step 3. Bitquery sends the query to the DB:</strong> The transformed query is then sent to MongoDB (which only contains b-prefixed and s-prefixed attributes). The DB returns a response that looks something like this (no h-prefixed attributes since they're not stored in the db)</p>
<pre><code class="hljs">{
  ...
  confirmed: [{
    ...
    out: [{
      b0: {
        op: <span class="hljs-number">106</span>
      },
      b1: <span class="hljs-string">"bQI="</span>,
      ...
    }]
    ...
  }]
  ...
}
</code></pre>
<p><strong>Step 4. Bitquery generates virtual attributes:</strong> The query engine then decodes above response to attach additional h-prefixed attributes, interpreted from the returned b-attributes. So the final response that's returned as the result is:</p>
<pre><code class="hljs">{
  ...
  confirmed: [{
    ...
    out: [{
      b0: {
        op: <span class="hljs-number">106</span>
      },
      b1: <span class="hljs-string">"bQI="</span>,
      h1: <span class="hljs-string">"6d02"</span>
      ...
    }]
    ...
  }]
  ...
}
</code></pre>
<p>Now the response contains the &quot;h1&quot; attribute, even though the database doesn't really need to store the hex encoded version. The client doesn't need to know about all this, and it appears as though BitDB contains the h-prefixed attributes. This approach can be extended to other types of attributes in the future in a scalable manner since all of this takes place in the code instead of the database.</p>
<p>To sum up:</p>
<ol>
<li>BitDB introduces virtual variables with <strong>h-prefix</strong> (h0, h1, h2, h3, ...) which are hex encoded representations of the b0, b1, b2, b3, etc. counterparts.</li>
<li>These are &quot;virtual&quot; and not stored in the DB. They are generated at query time and response time.</li>
<li>This is powerful because it doesn't involve storing additional data, yet greatly enhances the expressive power of the language.</li>
<li>Using this simple trick, Bitquery may introduce additional virtual attributes in the future depending on the needs.</li>
</ol>
<hr>
<h3><a class="anchor" aria-hidden="true" id="b-query"></a><a href="#b-query" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>B. Query</h3>
<h4><a class="anchor" aria-hidden="true" id="i-1-1-mapping-to-native-mongodb-query"></a><a href="#i-1-1-mapping-to-native-mongodb-query" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>i. 1:1 Mapping to Native MongoDB query</h4>
<p>The query object becomes translated into native MongoDB API call.</p>
<p>The currently supported query API methods are: <code>find</code>, <code>aggregate</code>, <code>project</code>, <code>sort</code>, <code>limit</code>, and <code>skip</code>, but this can be extended according to demand.</p>
<p>To learn how to query BitDB, you can just think of this as a regular MongoDB instance.</p>
<ul>
<li>You can learn more about MongoDB queries <a href="https://docs.mongodb.com/manual/tutorial/query-documents/">here</a></li>
<li>You can check out some example queries <a href="quickstart_v3">here</a></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="ii-specifying-the-database-to-query-against"></a><a href="#ii-specifying-the-database-to-query-against" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ii. Specifying the Database to Query against</h4>
<p>There are currently two separate collections in BitDB: <code>confirmed</code> and <code>unconfirmed</code>.</p>
<ul>
<li><strong>confirmed:</strong> Everything on the blockchain</li>
<li><strong>unconfirmed:</strong> Everything in the mempool</li>
</ul>
<p>By default, all queries are run against both <code>confirmed</code> and <code>unconfirmed</code> collections and returned as a unified object that looks like this:</p>
<pre><code class="hljs">{
  <span class="hljs-attr">"unconfirmed"</span>: [
    ...
  ],
  <span class="hljs-attr">"confirmed"</span>: [
    ...
  ]
}
</code></pre>
<p>However sometimes you may want to explicitly specify the database to query. You can use the <code>&quot;db&quot;</code> attribute, which can be:</p>
<ul>
<li><code>[&quot;u&quot;]</code>: unconfirmed only</li>
<li><code>[&quot;c&quot;]</code>: confirmed only</li>
<li><code>[&quot;u&quot;, &quot;c&quot;]</code>: both unconfirmed and confirmed (default)</li>
</ul>
<p><strong>Example 1.</strong> Find all confirmed transactions in blocks with block height (block index) larger than 400000 (only query &quot;confirmed&quot; since &quot;unconfirmed&quot; doesn't have a block):</p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"db"</span>: [<span class="hljs-string">"c"</span>],
    <span class="hljs-attr">"find"</span>: {
      <span class="hljs-attr">"blk.i"</span>: { <span class="hljs-attr">"$gt"</span>: <span class="hljs-number">400000</span> }
    } 
  }
}
</code></pre>
<p><strong>Example 2.</strong> Fetch all unconfirmed transactions in the mempool</p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"db"</span>: [<span class="hljs-string">"u"</span>],
    <span class="hljs-attr">"find"</span>: { } 
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="c-processing"></a><a href="#c-processing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C. Processing</h3>
<p>With version 3, Bitquery introduces an attribute called <strong>&quot;r&quot;</strong>, a response handler.</p>
<p>Currently there is only one type of response handler, named &quot;f&quot; (Response processing <strong>function</strong>). Here's an example (Pay attention to the &quot;r.f&quot; branch):</p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: { <span class="hljs-attr">"out.h1"</span>: <span class="hljs-string">"534c5000"</span>, <span class="hljs-attr">"out.s3"</span>: <span class="hljs-string">"GENESIS"</span> },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">"project"</span>: { <span class="hljs-attr">"out.$"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"_id"</span>: <span class="hljs-number">0</span> }
  },
  <span class="hljs-attr">"r"</span>: {
    <span class="hljs-attr">"f"</span>: <span class="hljs-string">"[.[] | .out[0] | { token_symbol: .s4, token_name: .s5, document_url: .s6} ]"</span>
  }
}
</code></pre>
<p>If we zoom in to the response processor function <code>r.f</code>:</p>
<pre><code class="hljs"><span class="hljs-string">"<span class="hljs-subst">[.[]</span> | .out<span class="hljs-subst">[0]</span> | { token_symbol: .s4, token_name: .s5, document_url: .s6} ]"</span>
</code></pre>
<p>It's a <a href="https://stedolan.github.io/jq/">jq</a> syntax that says <strong>&quot;for each item in the array (<code>.[]</code>), find the first output (<code>.out[0]</code>) and extract out its <code>.s4</code>, <code>.s5</code>, and <code>.s6</code> attributes to assign them to the custom attributes <code>&quot;token_symbol&quot;</code>, <code>&quot;token_name&quot;</code>, and <code>&quot;document_url&quot;</code></strong>.</p>
<p>Instead of returning all the raw non-human-readable <code>b-prefixed</code>, <code>h-prefixed</code>, or <code>s-prefixed</code> attributes straight from the DB, the API will return the response in the EXACT format you want:</p>
<pre><code class="hljs">{
  <span class="hljs-string">"unconfirmed"</span>: [{
    ...
  }],
  <span class="hljs-string">"confirmed"</span>: [{
    <span class="hljs-string">"token_symbol"</span>: <span class="hljs-string">"TEST"</span>,
    <span class="hljs-string">"token_name"</span>: <span class="hljs-string">"TEST"</span>,
    <span class="hljs-string">"document_url"</span>: <span class="hljs-string">"bitcoinfiles:b86b4bcbab7cd787b1c893ca101250c8c467dbba4df229b118218bd8a9e85a92"</span>
  }, {
    <span class="hljs-string">"token_symbol"</span>: <span class="hljs-string">"VOTE"</span>,
    <span class="hljs-string">"token_name"</span>: <span class="hljs-string">"An Election"</span>,
    <span class="hljs-string">"document_url"</span>: <span class="hljs-string">"bitcoinfiles:a90e59ef7ca66b25b6ba98d028198ae222a8229804c4b0b3bc0b1bafe104738a"</span>
  }, {
    <span class="hljs-string">"token_symbol"</span>: <span class="hljs-string">"WuCash"</span>,
    <span class="hljs-string">"token_name"</span>: <span class="hljs-string">"Wu Tang Cash"</span>,
    <span class="hljs-string">"document_url"</span>: <span class="hljs-string">"http://wu.cash"</span>
  }, {
    <span class="hljs-string">"token_symbol"</span>: <span class="hljs-string">"bb23n"</span>,
    <span class="hljs-string">"token_name"</span>: <span class="hljs-string">"bb23"</span>,
    <span class="hljs-string">"document_url"</span>: <span class="hljs-string">"bb23n.com"</span>
  }, {
    <span class="hljs-string">"token_symbol"</span>: <span class="hljs-string">"DBOOK01"</span>,
    <span class="hljs-string">"token_name"</span>: <span class="hljs-string">"Digital Book Example"</span>,
    <span class="hljs-string">"document_url"</span>: <span class="hljs-string">"https://digitalbookexampletokenurl.com"</span>
  }, {
    <span class="hljs-string">"token_symbol"</span>: <span class="hljs-string">""</span>
    <span class="hljs-string">"token_name"</span>: <span class="hljs-string">""</span>
    <span class="hljs-string">"document_url"</span>: <span class="hljs-string">""</span>
  }, {
    <span class="hljs-string">"token_symbol"</span>: <span class="hljs-string">"MTT"</span>,
    <span class="hljs-string">"token_name"</span>: <span class="hljs-string">"MyTestToken"</span>,
    <span class="hljs-string">"document_url"</span>: <span class="hljs-string">""</span>
  }]
}
</code></pre>
<blockquote>
<p>Note: The processing function gets executed for each database the query is run against.</p>
<p>This means &quot;u&quot; (unconfirmed) and &quot;c&quot; (confirmed) by default, but if you specify the db using the &quot;q.db&quot; attribute, the function will only be executed for that db collection</p>
</blockquote>
<p>As you can see, this effectively closes the loop in the entire query lifecycle by letting you create a query that describes <strong>NOT only the request, but also the response</strong>, which means a query is completely self-contained for instant usage.</p>
<blockquote>
<p>When we end up with a query language that is 100% self-contained for instant usage,</p>
<p>It is no longer just a query.</p>
<p>It is effectively an <strong>Open API</strong> (Application Programming Interface) for your application.</p>
</blockquote>
<p>Let's go through the detailed benefits of this approach:</p>
<h4><a class="anchor" aria-hidden="true" id="1-human-readable-api"></a><a href="#1-human-readable-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. Human Readable API</h4>
<p>The default <code>b-prefixed</code>, <code>h-prefixed</code>, or <code>s-prefixed</code> attribute names are NOT human processible--you have no idea what those attributes represent unless you look up the protocol specification--You probably want a more human readable attribute name for the protocol API, such as &quot;title&quot;, &quot;document_uri&quot;, &quot;username&quot;, etc.</p>
<h4><a class="anchor" aria-hidden="true" id="2-instant-open-api-for-your-app-protocol"></a><a href="#2-instant-open-api-for-your-app-protocol" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. Instant Open API for Your App Protocol</h4>
<p>By default, all bitdb responses are returned as <strong>a full transaction object</strong> unless a response processing function is applied. As an application protocol developer, this is NOT what you want because it's just a raw transaction.</p>
<p>If you want to create an ecosystem around your application protocol, there should be an easy way for you to just give away a simple recipe that 3rd party developers can drop into their apps. THAT's what most people expect when they think of an API. The raw Bitdb response doesn't facilitate that because it just returns the full transaction object.</p>
<p>This is where the response processing function comes in.</p>
<p><strong>Now you can embed the filtering logic directly into the query itself and open source that query.</strong> And the 3rd party developers who want to build on top of your application protocol can simply use that query, and your own application ecosystem is born, instantly.</p>
<h4><a class="anchor" aria-hidden="true" id="3-query-as-a-protocol-spec"></a><a href="#3-query-as-a-protocol-spec" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. Query as a Protocol Spec</h4>
<p>The human readable aspect is especially important when you want to publish your API to the world as &quot;open source&quot;, so anyone can understand and make use of it easily.</p>
<p>This means <strong>queries can now actually act as de facto protocol specification</strong> for any bitcoin applications.</p>
<p>If you're creating a bitcoin script based protocol and want to codify its behavior (instead of simply writing a whitepaper that can result in multiple interpretations depending on dfferent points of view), you can simply:</p>
<ol>
<li>Write a set of self-contained queries for your application</li>
<li>Open source this query in addition to the protocol spec.</li>
<li>Then anyone can tap into this query to use your application API.</li>
</ol>
<blockquote>
<p>This lack of a &quot;codified protocol&quot; is a very real problem. Many developers who want to build on top of bitcoin powered application protocols have hard time getting started because the protocol specs are not completely straight-forward and it's difficult to implement these protocols on their own.</p>
<p>If the app protocol developers open source the query along with their protocol specification, then all of this problem will go away and we will see way more innovation and mashups.</p>
<p>And more interoperability and more mashups will lead to more users and more engagement. The &quot;openness&quot; will be the competitive advantage.</p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="4-turing-complete-extensible-query-language"></a><a href="#4-turing-complete-extensible-query-language" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4. Turing Complete Extensible Query Language</h4>
<p>Bitquery makes use of <a href="https://stedolan.github.io/jq/">the popuar jq language</a> as the language of choice for describing the response processing logic. Here are some of the reasons why Bitquery uses jq:</p>
<ol>
<li><strong>Powerful:</strong> It's Turing Complete, meaning you can transform any JSON into any format you want.</li>
<li><strong>Efficient:</strong> It offloads the work from the database by doing all the filtering outside of the DB engine AFTER the DB responds, but BEFORE the result is sent back to the client.</li>
<li><strong>Portable:</strong> Most importantly, the language fits into JSON format, since it's a single line programming language (stack based).</li>
<li><strong>Programmable:</strong> Currently the most popular use case for jq is command line interface. People use it along with other programs on their computer through the power of <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">unix piping</a>, which makes it infinitely extensible and programmable.</li>
</ol>
<p>Here's an example of a jq-powered response filtering:</p>
<p><strong>&quot;Find 100 transactions with an output OP_RETURN script that starts with <code>0x6d02</code> (memo.cash). And then return only its block index, block time, and content.&quot;</strong></p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: { <span class="hljs-attr">"out.h1"</span>: <span class="hljs-string">"6d02"</span> },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">100</span>
  },
  <span class="hljs-attr">"r"</span>: {
    <span class="hljs-attr">"f"</span>: <span class="hljs-string">"[{ block: .blk.i?, timestamp: .blk.t?, content: .out[1].s2 }]"</span>
  }
}
</code></pre>
<hr>
<h2><a class="anchor" aria-hidden="true" id="3-example"></a><a href="#3-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. Example</h2>
<blockquote>
<p>All examples below contain <strong>&quot;v&quot;: 3</strong>, (version 3) you should also always include the version number (&quot;v&quot;: 3 at the moment) in all your queries to future-proof your applications.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="a-queries"></a><a href="#a-queries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A. queries</h3>
<hr>
<p>Find 10 OP_RETURN transactions that contains &quot;hello&quot; as the second push data:</p>
<ol>
<li>The first push data (b0) is <code>{&quot;op&quot;: 106}</code> (OP_RETURN)</li>
<li>The second push data in UTF encoding (s1) is &quot;hello&quot;</li>
</ol>
<p><a href="https://bitdb.network/v3/explorer/ewogICJ2IjogMywKICAicSI6IHsKICAgICJmaW5kIjogewogICAgICAib3V0LmIwIjogeyAib3AiOiAxMDYgfSwKICAgICAgIm91dC5zMSI6ICJoZWxsbyIKICAgIH0sCiAgICAibGltaXQiOiAxMAogIH0KfQ==">Try Query</a></p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: {
      <span class="hljs-attr">"out.b0"</span>: { <span class="hljs-attr">"op"</span>: <span class="hljs-number">106</span> },
      <span class="hljs-attr">"out.s1"</span>: <span class="hljs-string">"hello"</span>
    },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">10</span>
  }
}
</code></pre>
<hr>
<p>Find 10 transactions where the second push data is &quot;6d02&quot; in hex encoding</p>
<p><a href="https://bitdb.network/v3/explorer/ewogICJ2IjogMywKICAicSI6IHsKICAgICJmaW5kIjogeyAib3V0LmgxIjogIjZkMDIiIH0sCiAgICAibGltaXQiOiAxMAogIH0KfQ==">Try Query</a></p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: { <span class="hljs-attr">"out.h1"</span>: <span class="hljs-string">"6d02"</span> },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">10</span>
  }
}
</code></pre>
<hr>
<p>Find 10 transactions where <a href="https://github.com/fyookball/ChainBet/blob/master/PROTOCOL.md#op_return-communication-messages">the second push data is &quot;00424554&quot;</a></p>
<p><a href="https://bitdb.network/v3/explorer/ewogICJ2IjogMywKICAicSI6IHsKICAgICJmaW5kIjogeyAib3V0LmgxIjogIjAwNDI0NTU0IiB9LAogICAgImxpbWl0IjogMTAKICB9Cn0=">Try Query</a></p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: { <span class="hljs-attr">"out.h1"</span>: <span class="hljs-string">"00424554"</span> },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">10</span>
  }
}
</code></pre>
<hr>
<p>Find 10 transactions where the second push data is &quot;6d02&quot; in hex encoding, and the second push data matches &quot;bet&quot; in UTF8 (Note that it's combined with a full text search query for efficiency. Learn more about speeding up MongoDB regular expression queries here: <a href="https://medium.com/statuscode/how-to-speed-up-mongodb-regex-queries-by-a-factor-of-up-to-10-73995435c606">How to Speed-Up MongoDB Regex Queries by a Factor of up-to 10</a>)</p>
<p><a href="https://bitdb.network/v3/explorer/ewogICJ2IjogMywKICAicSI6IHsKICAgICJmaW5kIjogewogICAgICAiJHRleHQiOiB7ICIkc2VhcmNoIjogImJldCIgfSwKICAgICAgIm91dC5oMSI6ICI2ZDAyIiwKICAgICAgIm91dC5zMiI6IHsgIiRyZWdleCI6ICJiZXQiLCAiJG9wdGlvbnMiOiAiaSIgfQogICAgfSwKICAgICJsaW1pdCI6IDEwCiAgfQp9">Try Query</a></p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: {
      <span class="hljs-attr">"$text"</span>: { <span class="hljs-attr">"$search"</span>: <span class="hljs-string">"bet"</span> },
      <span class="hljs-attr">"out.h1"</span>: <span class="hljs-string">"6d02"</span>,
      <span class="hljs-attr">"out.s2"</span>: { <span class="hljs-attr">"$regex"</span>: <span class="hljs-string">"bet"</span>, <span class="hljs-attr">"$options"</span>: <span class="hljs-string">"i"</span> }
    },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">10</span>
  }
}
</code></pre>
<hr>
<p>Find 10 transactions with an input script with the sender <code>qq4kp3w3yhhvy4gm4jgeza4vus8vpxgrwc90n8rhxe</code></p>
<p><a href="https://bitdb.network/v3/explorer/ewogICJ2IjogMywKICAicSI6IHsKICAgICJmaW5kIjogeyAiaW4uZS5hIjogInFxNGtwM3czeWhodnk0Z200amdlemE0dnVzOHZweGdyd2M5MG44cmh4ZSIgfSwKICAgICJsaW1pdCI6IDEwCiAgfQp9">Try Query</a></p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: { <span class="hljs-attr">"in.e.a"</span>: <span class="hljs-string">"qq4kp3w3yhhvy4gm4jgeza4vus8vpxgrwc90n8rhxe"</span> },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">10</span>
  }
}
</code></pre>
<hr>
<h3><a class="anchor" aria-hidden="true" id="b-response-processing-function"></a><a href="#b-response-processing-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>B. response processing function</h3>
<p>In addition to the <code>q</code> attribute, we have a response handler <code>r.f</code>. which uses a popular stack based JSON processing language called <a href="https://stedolan.github.io/jq/">jq</a>. Example:</p>
<p>Find 100 transactions with an output OP_RETURN script that starts with <code>0x6d02</code> (memo.cash). And then return only its block index, block time, and content.</p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: { <span class="hljs-attr">"out.h1"</span>: <span class="hljs-string">"6d02"</span> },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">100</span>
  },
  <span class="hljs-attr">"r"</span>: {
    <span class="hljs-attr">"f"</span>: <span class="hljs-string">"[ { block: .blk.i?, timestamp: .blk.t?, content: .out[1].s2 } ]"</span>
  }
}
</code></pre>
<p>More complex example:</p>
<ol>
<li>Find 100 OP_RETURN transactions that start witn <code>0x6d02</code> (memo.cash)</li>
<li>Group by block index (blk.i)</li>
<li>Map the items to only return the message (.out[1].s2) and transaction hash (.tx.h)</li>
</ol>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"db"</span>: [<span class="hljs-string">"c"</span>],
    <span class="hljs-attr">"find"</span>: { <span class="hljs-attr">"out.h1"</span>: <span class="hljs-string">"6d02"</span> },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">100</span>
  },
  <span class="hljs-attr">"r"</span>: {
    <span class="hljs-attr">"f"</span>: <span class="hljs-string">"[ group_by(.blk.h)[] | { blocks: { (.[0].blk.i | tostring): [.[] | {message: .out[1].s2, tx: .tx.h} ] } } ]"</span>
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="misc"></a><a href="#misc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Misc.</h2>
<h3><a class="anchor" aria-hidden="true" id="db-side-filtering"></a><a href="#db-side-filtering" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DB-side filtering</h3>
<p>Another thing you can do to filter the query response is ask the database to do it. This can be done using MongoDB's <code>project</code>.</p>
<p>Unlike the <code>response filter</code> from the last section which takes place on the API server before responding to the client, the DB-side filtering actually takes place on the database engine therefore sometimes may be helpful (but not always)</p>
<blockquote>
<p>Caution: Adding too much stuff to the query via <code>aggregate</code>, etc. can put a large load on the server, so generally the response processing function is the recommended way to filter DB responses. (The response filter is fully capable of manipulating the response in all kinds of ways since it's powered by a turing complete JSON processing language called <a href="https://stedolan.github.io/jq">jq</a>.</p>
</blockquote>
<p>However, simple <code>project</code> queries that don't construct a huge query are OK because it reduces the DB load.</p>
<h4><a class="anchor" aria-hidden="true" id="a-project-reduces-the-db-load"></a><a href="#a-project-reduces-the-db-load" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A. 'project' reduces the DB load</h4>
<p>'project' reduces the amount of data the database has to send back, even before it reaches the response filter. The smaller this size is the faster the query will be.</p>
<h4><a class="anchor" aria-hidden="true" id="b-project-can-return-only-the-matched-subtree"></a><a href="#b-project-can-return-only-the-matched-subtree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>B. 'project' can return ONLY the matched subtree</h4>
<p>For example, you may be looking for a transaction that matches a certain OP_RETURN pattern in its output.</p>
<p>By default all BitDB queries return the entire transaction, so you may want to ask it to only return the matched OP_RETURN output. You can do this by using MongoDB's <a href="https://docs.mongodb.com/manual/reference/operator/projection/positional/">Positional Operator $</a>.</p>
<p><a href="https://bitdb.network/v3/explorer/ewogICJ2IjogMiwKICAiZSI6IHsgIm91dC5iMSI6ICJoZXgiIH0sCiAgInEiOiB7CiAgICAiZmluZCI6IHsgIm91dC5iMSI6ICI2ZDAyIiB9LAogICAgImxpbWl0IjogMTAsCiAgICAicHJvamVjdCI6IHsKICAgICAgIm91dC4kIjogMQogICAgfQogIH0KfQ==">Try Query</a></p>
<pre><code class="hljs">{
  <span class="hljs-attr">"v"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"q"</span>: {
    <span class="hljs-attr">"find"</span>: { <span class="hljs-attr">"out.h1"</span>: <span class="hljs-string">"6d02"</span> },
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">10</span>,
    <span class="hljs-attr">"project"</span>: { <span class="hljs-attr">"out.$"</span>: <span class="hljs-number">1</span> }
  }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav docOnPageNav"><ul class="toc-headings"><li><a href="#1-bitdb-document-format">1. BitDB Document Format</a></li><li><a href="#2-bitquery-bitdb-query-language">2. Bitquery: BitDB Query Language</a><ul class="toc-headings"><li><a href="#a-encoding">A. Encoding</a></li><li><a href="#b-query">B. Query</a></li><li><a href="#c-processing">C. Processing</a></li></ul></li><li><a href="#3-example">3. Example</a><ul class="toc-headings"><li><a href="#a-queries">A. queries</a></li><li><a href="#b-response-processing-function">B. response processing function</a></li></ul></li><li><a href="#misc">Misc.</a><ul class="toc-headings"><li><a href="#db-side-filtering">DB-side filtering</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"></footer></div></body></html>